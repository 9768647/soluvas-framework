<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:commons="http://www.soluvas.org/schema/commons/1.0" xmlns:data="http://www.soluvas.org/schema/data/1.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.soluvas.org/schema/data/1.0">
  <xsd:import namespace="http://www.omg.org/XMI" schemaLocation="platform:/plugin/org.eclipse.emf.ecore/model/XMI.xsd"/>
  <xsd:import namespace="http://www.soluvas.org/schema/commons/1.0" schemaLocation="commons.xsd"/>
  <xsd:simpleType name="AttributeSemantic">
    <xsd:restriction base="xsd:NCName">
      <xsd:enumeration value="equal"/>
      <xsd:enumeration value="less_than"/>
      <xsd:enumeration value="less_than_or_equal"/>
      <xsd:enumeration value="greater_than"/>
      <xsd:enumeration value="greater_than_or_equal"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" name="AttributeType">
    <xsd:annotation>
      <xsd:documentation>EXPERIMENTAL.

Two/three approaches:

1. Mixin must be statically designed into Ecore EClass, e.g. BerbatikBags, which inherits from BerbatikMixin (inherits ClothingMixin = SizeMixin + ColorMixin), BatikMixin, and BagsMixin. The upside is all attributes/references merge into the EObject. Downside is we need to permutate all combinations into EClass.
Not sure yet how it goes with MongoDB, JSON, and XMI import/export. Not sure yet how it goes with VariedProduct, BundleProduct, SubscribedProduct, SharedProduct, etc.

2. Mixin is dynamic. Each product object maintain a list of MixinTypes (which is by default specified when the product is created), and filled mixins are put in an EList. Mixins can be added and removed during runtime, without any build-time project rebuild or EMF regeneration.
So store owner, even staff, can define new mixin and manipulate existing products with ease. No Mall admin or schema changes required.
Store staff can browse available mixin types and just add any mixin they want.
Similar approach with Drupal taxonomy or JCR mixin. Magento is more restrictive because of its inflexible AttributeSet concept. Mixin is like AttributeSet but with cardinality 0..*.
Probably need better name than mixin though.
Seems to be most flexible, for Jackson we can have custom converter. My concern is MongoDB and XMI.
Not sure yet how it goes with MongoDB, JSON, and XMI import/export. Not sure yet how it goes with VariedProduct, BundleProduct, SubscribedProduct, SharedProduct, etc.

3. Hybrid #1. Mixin is by default static, which hopefully covers 80% use case.
When you want dynamic, you can add more mixins.
But ain't this too complicated?
On the web client side, it's also more work. Not to mention inventory, etc. integration with other systems.
ProductInfo &amp; principal etc. also use the fully dynamic approach.

4. Hybrid #2. Mixin is by default dynamic, which covers 80% of the customization.
And for things like category, tag, color, size, they're static, with code support. i.e. must be generated by EMF.
</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="commons:NsPrefixable">
        <xsd:attribute name="name" type="xsd:string" use="required"/>
        <xsd:attribute name="resourceType" type="commons:ResourceType"/>
        <xsd:attribute name="resourceUri" type="xsd:string"/>
        <xsd:attribute name="resourceName" type="xsd:string"/>
        <xsd:attribute name="label" type="xsd:string"/>
        <xsd:attribute name="minValues" type="xsd:long">
          <xsd:annotation>
            <xsd:documentation>0 means optional, 1 means required, and so on.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="maxValues" type="xsd:long">
          <xsd:annotation>
            <xsd:documentation>1 means singular. -1 means no maximum number of values.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="dataTypeName" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="AttributeType" type="data:AttributeType">
    <xsd:annotation>
      <xsd:documentation>EXPERIMENTAL.

Two/three approaches:

1. Mixin must be statically designed into Ecore EClass, e.g. BerbatikBags, which inherits from BerbatikMixin (inherits ClothingMixin = SizeMixin + ColorMixin), BatikMixin, and BagsMixin. The upside is all attributes/references merge into the EObject. Downside is we need to permutate all combinations into EClass.
Not sure yet how it goes with MongoDB, JSON, and XMI import/export. Not sure yet how it goes with VariedProduct, BundleProduct, SubscribedProduct, SharedProduct, etc.

2. Mixin is dynamic. Each product object maintain a list of MixinTypes (which is by default specified when the product is created), and filled mixins are put in an EList. Mixins can be added and removed during runtime, without any build-time project rebuild or EMF regeneration.
So store owner, even staff, can define new mixin and manipulate existing products with ease. No Mall admin or schema changes required.
Store staff can browse available mixin types and just add any mixin they want.
Similar approach with Drupal taxonomy or JCR mixin. Magento is more restrictive because of its inflexible AttributeSet concept. Mixin is like AttributeSet but with cardinality 0..*.
Probably need better name than mixin though.
Seems to be most flexible, for Jackson we can have custom converter. My concern is MongoDB and XMI.
Not sure yet how it goes with MongoDB, JSON, and XMI import/export. Not sure yet how it goes with VariedProduct, BundleProduct, SubscribedProduct, SharedProduct, etc.

3. Hybrid #1. Mixin is by default static, which hopefully covers 80% use case.
When you want dynamic, you can add more mixins.
But ain't this too complicated?
On the web client side, it's also more work. Not to mention inventory, etc. integration with other systems.
ProductInfo &amp; principal etc. also use the fully dynamic approach.

4. Hybrid #2. Mixin is by default dynamic, which covers 80% of the customization.
And for things like category, tag, color, size, they're static, with code support. i.e. must be generated by EMF.
</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="Value">
    <xsd:annotation>
      <xsd:documentation>Attribute having single or multiple values.

{
attributes:
  color: [{value: "red", displayValue: "Merah"}],
  berbatikMaterial: [{value: "katun", displayValue: "Katun"}],
  berbatikShawlLength: [{value: "90cm", displayValue: "90 cm"}],
mixins: {
  "color": {
    attributeTypes: {
      color: {className: "TermValue", "name": "color", "label": "Warna"}, // nsPrefix: builtin
    },
  "berbatik": {
    attributeTypes: {
      berbatikMaterial: {className: "TermValue", nsPrefix: "berbatik", name: "material", label: "Material"},
      berbatikBatikAge: {className: "TermValue", nsPrefix: "berbatik", name: "batikAge", label: "Batik Age"},
    }
  },
}


"berbatik:material": [{value: "Katun"}],

nggak enak:
product['berbatik:material'][0].displayValue

lebih enak:

&lt;p&gt;Warna: {{product.attributes.color.0.displayValue}}&lt;/p&gt;
&lt;p&gt;Material: {{product.attributes.berbatikMaterial.0.displayValue}}&lt;/p&gt;
</xsd:documentation>
    </xsd:annotation>
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="semantic" type="data:AttributeSemantic">
      <xsd:annotation>
        <xsd:documentation>Optional semantic of this value.

i.e. value = 50 cm, semantic = less than, means "&lt; 50 cm".</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="displayValue" type="xsd:string"/>
  </xsd:complexType>
  <xsd:element name="Value" type="data:Value">
    <xsd:annotation>
      <xsd:documentation>Attribute having single or multiple values.

{
attributes:
  color: [{value: "red", displayValue: "Merah"}],
  berbatikMaterial: [{value: "katun", displayValue: "Katun"}],
  berbatikShawlLength: [{value: "90cm", displayValue: "90 cm"}],
mixins: {
  "color": {
    attributeTypes: {
      color: {className: "TermValue", "name": "color", "label": "Warna"}, // nsPrefix: builtin
    },
  "berbatik": {
    attributeTypes: {
      berbatikMaterial: {className: "TermValue", nsPrefix: "berbatik", name: "material", label: "Material"},
      berbatikBatikAge: {className: "TermValue", nsPrefix: "berbatik", name: "batikAge", label: "Batik Age"},
    }
  },
}


"berbatik:material": [{value: "Katun"}],

nggak enak:
product['berbatik:material'][0].displayValue

lebih enak:

<p>Warna: {{product.attributes.color.0.displayValue}}</p>
<p>Material: {{product.attributes.berbatikMaterial.0.displayValue}}</p>
</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="StringValue">
    <xsd:complexContent>
      <xsd:extension base="data:Value">
        <xsd:attribute name="value" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="StringValue" type="data:StringValue"/>
  <xsd:complexType name="MeasureValue">
    <xsd:annotation>
      <xsd:documentation>Mixin with measured unit.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="data:Value">
        <xsd:attribute name="valueUnit" type="xsd:string"/>
        <xsd:attribute name="value" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="MeasureValue" type="data:MeasureValue">
    <xsd:annotation>
      <xsd:documentation>Mixin with measured unit.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="CurrencyValue">
    <xsd:annotation>
      <xsd:documentation>Mixin with monetary value and currency code.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="data:Value">
        <xsd:attribute name="currencyUnit" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="CurrencyValue" type="data:CurrencyValue">
    <xsd:annotation>
      <xsd:documentation>Mixin with monetary value and currency code.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="Mixin">
    <xsd:complexContent>
      <xsd:extension base="commons:NameContainer">
        <xsd:choice maxOccurs="unbounded" minOccurs="0">
          <xsd:element name="attributeTypes" type="data:AttributeType"/>
        </xsd:choice>
        <xsd:attribute name="resourceType" type="commons:ResourceType"/>
        <xsd:attribute name="resourceUri" type="xsd:string"/>
        <xsd:attribute name="resourceName" type="xsd:string"/>
        <xsd:attribute name="nsPrefix" type="xsd:string"/>
        <xsd:attribute name="description" type="xsd:string"/>
        <xsd:attribute name="attributeTypes" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="Mixin" type="data:Mixin"/>
  <xsd:complexType name="RangeValue">
    <xsd:annotation>
      <xsd:documentation>Range attribute's primary value can be either the start or end value.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="data:Value">
        <xsd:attribute name="startValue" type="xsd:string"/>
        <xsd:attribute name="endValue" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="RangeValue" type="data:RangeValue">
    <xsd:annotation>
      <xsd:documentation>Range attribute's primary value can be either the start or end value.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="TermValue">
    <xsd:annotation>
      <xsd:documentation>Use a taxonomy term. 'value' is the ID of the term.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="data:Value">
        <xsd:choice maxOccurs="unbounded" minOccurs="0">
          <xsd:element name="term" type="data:Term"/>
        </xsd:choice>
        <xsd:attribute name="id" type="xsd:string"/>
        <xsd:attribute name="slug" type="xsd:string"/>
        <xsd:attribute name="slugPath" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>'/'-separated slug path.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="value" type="xsd:string"/>
        <xsd:attribute name="term" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="TermValue" type="data:TermValue">
    <xsd:annotation>
      <xsd:documentation>Use a taxonomy term. 'value' is the ID of the term.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="Vocab">
    <xsd:annotation>
      <xsd:documentation>pindah jd attributetype.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="data:TermContainer">
        <xsd:attribute name="resourceType" type="commons:ResourceType"/>
        <xsd:attribute name="resourceUri" type="xsd:string"/>
        <xsd:attribute name="resourceName" type="xsd:string"/>
        <xsd:attribute name="nsPrefix" type="xsd:string"/>
        <xsd:attribute name="description" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="Vocab" type="data:Vocab">
    <xsd:annotation>
      <xsd:documentation>pindah jd attributetype.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="Term">
    <xsd:complexContent>
      <xsd:extension base="data:TermContainer">
        <xsd:choice maxOccurs="unbounded" minOccurs="0">
          <xsd:element name="vocab" type="data:Vocab"/>
        </xsd:choice>
        <xsd:attribute name="name" type="xsd:string" use="required"/>
        <xsd:attribute name="resourceType" type="commons:ResourceType"/>
        <xsd:attribute name="resourceUri" type="xsd:string"/>
        <xsd:attribute name="resourceName" type="xsd:string"/>
        <xsd:attribute name="vocab" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="Term" type="data:Term"/>
  <xsd:complexType name="ListVocab">
    <xsd:complexContent>
      <xsd:extension base="data:Vocab"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ListVocab" type="data:ListVocab"/>
  <xsd:complexType name="TreeVocab">
    <xsd:complexContent>
      <xsd:extension base="data:Vocab"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="TreeVocab" type="data:TreeVocab"/>
  <xsd:complexType name="FreeVocab">
    <xsd:complexContent>
      <xsd:extension base="data:Vocab"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="FreeVocab" type="data:FreeVocab"/>
  <xsd:complexType abstract="true" name="TermContainer">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element name="terms" type="data:Term">
        <xsd:annotation>
          <xsd:documentation>List of terms in a Vocabulary or if the Term is nested (tree vocabulary).</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="terms" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>List of terms in a Vocabulary or if the Term is nested (tree vocabulary).</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:element name="TermContainer" type="data:TermContainer"/>
  <xsd:complexType name="DataCatalog">
    <xsd:complexContent>
      <xsd:extension base="commons:BundleAware">
        <xsd:choice maxOccurs="unbounded" minOccurs="0">
          <xsd:element name="vocabs" type="data:Vocab"/>
          <xsd:element name="mixins" type="data:Mixin"/>
          <xsd:element name="terms" type="data:Term"/>
          <xsd:element name="attributeTypes" type="data:AttributeType"/>
        </xsd:choice>
        <xsd:attribute name="resourceType" type="commons:ResourceType"/>
        <xsd:attribute name="resourceUri" type="xsd:string"/>
        <xsd:attribute name="resourceName" type="xsd:string"/>
        <xsd:attribute name="name" type="xsd:string" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="DataCatalog" type="data:DataCatalog"/>
</xsd:schema>
