<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:image="http://www.soluvas.org/schema/image/1.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.soluvas.org/schema/image/1.0">
  <xsd:import namespace="http://www.omg.org/XMI" schemaLocation="platform:/plugin/org.eclipse.emf.ecore/model/XMI.xsd"/>
  <xsd:simpleType name="ImageTransformType">
    <xsd:restriction base="xsd:NCName">
      <xsd:enumeration value="resize_to_fit">
        <xsd:annotation>
          <xsd:documentation>Create thumbnail with same aspect ratio.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="resize_to_fill">
        <xsd:annotation>
          <xsd:documentation>Fill thumbnail dimension.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="ImageConfig">
    <xsd:annotation>
      <xsd:documentation>Image module configuration.

The URI pattern is hardcoded as folows:

For normal styles:

* {publicUri}/{namespace}/{styleCode}/{id}_{styleCode}.{extension}

For variant styles: (styleCode is usually 'x', but can be anything else except 'o')

* {publicUri}/{namespace}/{styleCode}/{id}_{styleCode}_{variantCode}.{extension}

In the future, URI pattern ("template") should be configurable, based on http://tools.ietf.org/html/rfc6570
and can be expanded both by server and client scripts.

The domain name can also be different for each namespace, or even for each styleCode or variantCode.
</xsd:documentation>
    </xsd:annotation>
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="publicUri" type="xsd:string"/>
  </xsd:complexType>
  <xsd:element name="ImageConfig" type="image:ImageConfig">
    <xsd:annotation>
      <xsd:documentation>Image module configuration.

The URI pattern is hardcoded as folows:

For normal styles:

* {publicUri}/{namespace}/{styleCode}/{id}_{styleCode}.{extension}

For variant styles: (styleCode is usually 'x', but can be anything else except 'o')

* {publicUri}/{namespace}/{styleCode}/{id}_{styleCode}_{variantCode}.{extension}

In the future, URI pattern ("template") should be configurable, based on http://tools.ietf.org/html/rfc6570
and can be expanded both by server and client scripts.

The domain name can also be different for each namespace, or even for each styleCode or variantCode.
</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="ImageConnector">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageConnector" type="image:ImageConnector"/>
  <xsd:complexType name="DavConnector">
    <xsd:annotation>
      <xsd:documentation>Store images using any WebDAV Protocol compatible server, such as Apache, nginx, Sling, Alfresco, Magnolia.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageConnector"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="DavConnector" type="image:DavConnector">
    <xsd:annotation>
      <xsd:documentation>Store images using any WebDAV Protocol compatible server, such as Apache, nginx, Sling, Alfresco, Magnolia.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="S3Connector">
    <xsd:annotation>
      <xsd:documentation>Store images using Amazon S3 or S3 API-compatible servers such as Ceph, Parkplace, Boardwalk. fakes3 is not working due to it creating folders, not actually storing files.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageConnector"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="S3Connector" type="image:S3Connector">
    <xsd:annotation>
      <xsd:documentation>Store images using Amazon S3 or S3 API-compatible servers such as Ceph, Parkplace, Boardwalk. fakes3 is not working due to it creating folders, not actually storing files.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="ImageTransformer">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element name="source" type="image:ImageConnector">
        <xsd:annotation>
          <xsd:documentation>Source image connector.

Thumbnailator will use this to get the origin URI and download the  image, before transforming it locally.

Blitline will use it to get the origin URI, but processing will be done by Blitline itself.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="source" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>Source image connector.

Thumbnailator will use this to get the origin URI and download the  image, before transforming it locally.

Blitline will use it to get the origin URI, but processing will be done by Blitline itself.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:element name="ImageTransformer" type="image:ImageTransformer"/>
  <xsd:complexType name="BlitlineTransformer">
    <xsd:annotation>
      <xsd:documentation>Processes using Blitline. The source image must be publicly hosted, for example using S3.

The destination image is directly written into an S3 bucket. Make sure to set the Canonical ID, see http://blog.blitline.com/post/32296310740/canonical-id-s3-permissions</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransformer">
        <xsd:attribute name="applicationId" type="xsd:string"/>
        <xsd:attribute name="bucket" type="xsd:string"/>
        <xsd:attribute name="prefix" type="xsd:string"/>
        <xsd:attribute name="keyTemplate" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>key template in URI template format.

Variables are: namespace, styleCode, imageId, styleVariant, extension.

Default is: "{+prefix}{namespace}/{styleCode}/{imageId}_{styleVariant}.{extension}";</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="BlitlineTransformer" type="image:BlitlineTransformer">
    <xsd:annotation>
      <xsd:documentation>Processes using Blitline. The source image must be publicly hosted, for example using S3.

The destination image is directly written into an S3 bucket. Make sure to set the Canonical ID, see http://blog.blitline.com/post/32296310740/canonical-id-s3-permissions</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="ThumbnailatorTransformer">
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransformer"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ThumbnailatorTransformer" type="image:ThumbnailatorTransformer"/>
  <xsd:complexType name="UploadedImage">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="uri" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>Public URI, usually CDN. This may be cached, so it's not a good fit for input to ImageTransformer.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="originUri" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>URI for direct access to object storage.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="styleCode" type="xsd:string"/>
    <xsd:attribute name="styleVariant" type="xsd:string"/>
    <xsd:attribute name="extension" type="xsd:string"/>
    <xsd:attribute name="size" type="xsd:long">
      <xsd:annotation>
        <xsd:documentation>File size in bytes.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="width" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Width in pixels, useful for IMG tag.

Note: Connectors won't return this, but Transformers would.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="height" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Height in pixels, useful for IMG tag.

Note: Connectors won't return this, but Transformers would.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:element name="UploadedImage" type="image:UploadedImage"/>
  <xsd:complexType name="ImageManager">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageManager" type="image:ImageManager"/>
  <xsd:complexType abstract="true" name="ImageTransform">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageTransform" type="image:ImageTransform"/>
  <xsd:complexType name="ResizeToFit">
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransform">
        <xsd:attribute name="width" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Width of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="height" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Height of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ResizeToFit" type="image:ResizeToFit"/>
  <xsd:complexType name="ResizeToFill">
    <xsd:annotation>
      <xsd:documentation>Resize the image to fit within the specified dimensions while retaining the aspect ratio of the original image. If necessary, crop the image in the larger dimension

Common English Translation: This is probably the crop you want if you want to cut a center piece out of a photo and use it as a thumbnail. This wont do any scaling, only cut out the center (by default) to your defined size.

"name": "resize_to_fill",
"params" : { "width" : 40, "height" : 40 }</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransform">
        <xsd:attribute name="width" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Width of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="height" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Height of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="gravity" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>Location of crop (defaults to 'CenterGravity')</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="onlyShrinkLarger" type="xsd:boolean">
          <xsd:annotation>
            <xsd:documentation>Don’t upsize image (defaults to false)</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ResizeToFill" type="image:ResizeToFill">
    <xsd:annotation>
      <xsd:documentation>Resize the image to fit within the specified dimensions while retaining the aspect ratio of the original image. If necessary, crop the image in the larger dimension

Common English Translation: This is probably the crop you want if you want to cut a center piece out of a photo and use it as a thumbnail. This wont do any scaling, only cut out the center (by default) to your defined size.

"name": "resize_to_fill",
"params" : { "width" : 40, "height" : 40 }</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="DimensionLike">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="width" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Width of desired image</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="height" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Height of desired image</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:element name="DimensionLike" type="image:DimensionLike"/>
  <xsd:complexType name="ImageVariant">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="styleCode" type="xsd:string"/>
    <xsd:attribute name="styleVariant" type="xsd:string"/>
    <xsd:attribute name="extension" type="xsd:string"/>
  </xsd:complexType>
  <xsd:element name="ImageVariant" type="image:ImageVariant"/>
</xsd:schema>
