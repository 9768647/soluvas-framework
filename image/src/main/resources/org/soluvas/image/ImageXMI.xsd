<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:commons="http://www.soluvas.org/schema/commons/1.0" xmlns:image="http://www.soluvas.org/schema/image/1.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.soluvas.org/schema/image/1.0">
  <xsd:import namespace="http://www.soluvas.org/schema/commons/1.0" schemaLocation="commons.xsd"/>
  <xsd:import namespace="http://www.omg.org/XMI" schemaLocation="platform:/plugin/org.eclipse.emf.ecore/model/XMI.xsd"/>
  <xsd:simpleType name="ImageTransformType">
    <xsd:restriction base="xsd:NCName">
      <xsd:enumeration value="resize_to_fit">
        <xsd:annotation>
          <xsd:documentation>Create thumbnail with same aspect ratio.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="resize_to_fill">
        <xsd:annotation>
          <xsd:documentation>Fill thumbnail dimension.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="FileExport">
    <xsd:restriction base="xsd:NCName">
      <xsd:enumeration value="original"/>
      <xsd:enumeration value="style"/>
      <xsd:enumeration value="all"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DuplicateIdHandling">
    <xsd:restriction base="xsd:NCName">
      <xsd:enumeration value="skip">
        <xsd:annotation>
          <xsd:documentation>If ID already exists, skip (default, safest)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="overwrite">
        <xsd:annotation>
          <xsd:documentation>If ID already exists, overwrite (common use)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="add">
        <xsd:annotation>
          <xsd:documentation>If ID already exists, upload new image (not very useful)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="error">
        <xsd:annotation>
          <xsd:documentation>If ID already exists, throw error (strict)</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType abstract="true" name="ImageConnector">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageConnector" type="image:ImageConnector"/>
  <xsd:complexType name="DavConnector">
    <xsd:annotation>
      <xsd:documentation>Store images using any WebDAV Protocol compatible server, such as Apache, nginx, Sling, Alfresco, Magnolia.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageConnector"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="DavConnector" type="image:DavConnector">
    <xsd:annotation>
      <xsd:documentation>Store images using any WebDAV Protocol compatible server, such as Apache, nginx, Sling, Alfresco, Magnolia.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="S3Connector">
    <xsd:annotation>
      <xsd:documentation>Store images using Amazon S3 or S3 API-compatible servers such as Ceph, Parkplace, Boardwalk. fakes3 is not working due to it creating folders, not actually storing files.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageConnector">
        <xsd:attribute name="canonicalUserId" type="xsd:string"/>
        <xsd:attribute name="bucket" type="xsd:string"/>
        <xsd:attribute name="tenantId" type="xsd:string"/>
        <xsd:attribute name="tenantEnv" type="xsd:string"/>
        <xsd:attribute name="originAlias" type="xsd:string"/>
        <xsd:attribute name="cdnAlias" type="xsd:string"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="S3Connector" type="image:S3Connector">
    <xsd:annotation>
      <xsd:documentation>Store images using Amazon S3 or S3 API-compatible servers such as Ceph, Parkplace, Boardwalk. fakes3 is not working due to it creating folders, not actually storing files.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="ImageTransformer">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageTransformer" type="image:ImageTransformer"/>
  <xsd:complexType name="BlitlineTransformer">
    <xsd:annotation>
      <xsd:documentation>Processes using Blitline. The source image must be publicly hosted, for example using S3.
Blitline will use source to get the origin URI, but processing will be done by Blitline itself.

The destination image is directly written into an S3 bucket.

You must have an S3 account and have permissions to change the policy on your bucket
For these instructions, you must use the Amazon AWS Console
See: http://www.blitline.com/docs/s3_permissions

Make sure to set the Canonical ID, see http://blog.blitline.com/post/32296310740/canonical-id-s3-permissions</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransformer">
        <xsd:attribute name="applicationId" type="xsd:string"/>
        <xsd:attribute name="bucket" type="xsd:string"/>
        <xsd:attribute name="tenantId" type="xsd:string"/>
        <xsd:attribute name="tenantEnv" type="xsd:string"/>
        <xsd:attribute name="cdnAlias" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>CDN alias (if available), e.g. pic.stg.berbatik.com.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="keyTemplate" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>key template in URI template format.

Variables are: tenantId, tenantEnv,
namespace, styleCode, imageId, styleVariant, extension.

Default is: "{tenantId}_{tenantEnv}/{namespace}/{styleCode}/{imageId}_{styleVariant}.{extension}";</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="uriTemplate" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>URI template for 'lo' (derived) images, optionally with CDN. This template will be used on 3 areas: server-side, email templating, and client-side JavaScript.

Variables are: namespace, styleCode, imageId, styleVariant, ext.

Default is: http://{+alias}/{tenantId}_{tenantEnv}/{namespace}/{styleCode}/{imageId}_{styleVariant}.{extension}</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="originUriTemplate" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>URI template for 'lo' (derived) images, without CDN. This template will be used on 3 areas: server-side, email templating, and client-side JavaScript.

Variables are: namespace, styleCode, imageId, styleVariant, ext.

Default is: http://{+alias}/{tenantId}_{tenantEnv}/{namespace}/{styleCode}/{imageId}_{styleVariant}.{extension}</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="BlitlineTransformer" type="image:BlitlineTransformer">
    <xsd:annotation>
      <xsd:documentation>Processes using Blitline. The source image must be publicly hosted, for example using S3.
Blitline will use source to get the origin URI, but processing will be done by Blitline itself.

The destination image is directly written into an S3 bucket.

You must have an S3 account and have permissions to change the policy on your bucket
For these instructions, you must use the Amazon AWS Console
See: http://www.blitline.com/docs/s3_permissions

Make sure to set the Canonical ID, see http://blog.blitline.com/post/32296310740/canonical-id-s3-permissions</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="ThumbnailatorTransformer">
    <xsd:annotation>
      <xsd:documentation>Thumbnailator will use this to get the origin URI and download the  image, before transforming it locally.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransformer"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ThumbnailatorTransformer" type="image:ThumbnailatorTransformer">
    <xsd:annotation>
      <xsd:documentation>Thumbnailator will use this to get the origin URI and download the  image, before transforming it locally.</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="UploadedImage">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="uri" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>Public URI, usually CDN. This may be cached, so it's not a good fit for input to ImageTransformer.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="originUri" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>URI for direct access to object storage.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="styleCode" type="xsd:string"/>
    <xsd:attribute name="styleVariant" type="xsd:string"/>
    <xsd:attribute name="extension" type="xsd:string"/>
    <xsd:attribute name="size" type="xsd:long">
      <xsd:annotation>
        <xsd:documentation>File size in bytes. A transformer like Blitline is unable to provide this information immediately, an enhanced Blitlines transformer can update the size independently and asynchronously</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="width" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Width in pixels, useful for IMG tag.

Note: Connectors won't return this, but Transformers would.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="height" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Height in pixels, useful for IMG tag.

Note: Connectors won't return this, but Transformers would.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:element name="UploadedImage" type="image:UploadedImage"/>
  <xsd:complexType name="ImageManager">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageManager" type="image:ImageManager"/>
  <xsd:complexType abstract="true" name="ImageTransform">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageTransform" type="image:ImageTransform"/>
  <xsd:complexType name="ResizeToFit">
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransform">
        <xsd:attribute name="width" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Width of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="height" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Height of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ResizeToFit" type="image:ResizeToFit"/>
  <xsd:complexType name="ResizeToFill">
    <xsd:annotation>
      <xsd:documentation>Resize the image to fit within the specified dimensions while retaining the aspect ratio of the original image. If necessary, crop the image in the larger dimension

Common English Translation: This is probably the crop you want if you want to cut a center piece out of a photo and use it as a thumbnail. This wont do any scaling, only cut out the center (by default) to your defined size.

"name": "resize_to_fill",
"params" : { "width" : 40, "height" : 40 }</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="image:ImageTransform">
        <xsd:attribute name="width" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Width of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="height" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Height of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="gravity" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>Location of crop (defaults to 'CenterGravity')</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="onlyShrinkLarger" type="xsd:boolean">
          <xsd:annotation>
            <xsd:documentation>Don’t upsize image (defaults to false)</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ResizeToFill" type="image:ResizeToFill">
    <xsd:annotation>
      <xsd:documentation>Resize the image to fit within the specified dimensions while retaining the aspect ratio of the original image. If necessary, crop the image in the larger dimension

Common English Translation: This is probably the crop you want if you want to cut a center piece out of a photo and use it as a thumbnail. This wont do any scaling, only cut out the center (by default) to your defined size.

"name": "resize_to_fill",
"params" : { "width" : 40, "height" : 40 }</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType abstract="true" name="DimensionLike">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="width" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Width of desired image</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="height" type="xsd:int">
      <xsd:annotation>
        <xsd:documentation>Height of desired image</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:element name="DimensionLike" type="image:DimensionLike"/>
  <xsd:complexType name="ImageVariant">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
    <xsd:attribute name="styleCode" type="xsd:string"/>
    <xsd:attribute name="styleVariant" type="xsd:string"/>
    <xsd:attribute name="extension" type="xsd:string"/>
  </xsd:complexType>
  <xsd:element name="ImageVariant" type="image:ImageVariant"/>
  <xsd:complexType name="Image">
    <xsd:annotation>
      <xsd:documentation>The v1 structure is as follows:

			dbo.put("_id", imageId);
			dbo.put("name", name); // in v1: Only used for creating/uploading new image. Otherwise it's always null.
			dbo.put("uri", originalUri);
			dbo.put("fileName", originalName);
			dbo.put("contentType", contentType);
			dbo.put("size", (int)length);
			final Date creationTime = new Date();
			dbo.put("created", creationTime);
			dbo.put("styles", stylesObj);
- originalFile : transient

v2 adds:

			dbo.put("name", name); // in v2: serialized
			dbo.put("originUri", originalOriginUri);
			dbo.put("extension", extension);
			dbo.put("creationTime", creationTime);
- modificationTime
- width
- height
- linkedFile</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="commons:Identifiable">
        <xsd:choice maxOccurs="unbounded" minOccurs="0">
          <xsd:element name="styles" type="image:StyledImage"/>
        </xsd:choice>
        <xsd:attribute name="name" type="xsd:string" use="required"/>
        <xsd:attribute name="creationTime" type="xsd:string"/>
        <xsd:attribute name="modificationTime" type="xsd:string"/>
        <xsd:attribute name="width" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Width of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="height" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Height of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="schemaVersion" type="xsd:long"/>
        <xsd:attribute name="uri" type="xsd:string"/>
        <xsd:attribute name="fileName" type="xsd:string"/>
        <xsd:attribute name="contentType" type="xsd:string"/>
        <xsd:attribute name="size" type="xsd:long"/>
        <xsd:attribute name="created" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>DEPRECATED.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="originUri" type="xsd:string"/>
        <xsd:attribute name="extension" type="xsd:string"/>
        <xsd:attribute name="linkedFile" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>Image file name, relative to XMI file path inside the export folder or archive file. Only used for XMI data.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="Image" type="image:Image">
    <xsd:annotation>
      <xsd:documentation>The v1 structure is as follows:

			dbo.put("_id", imageId);
			dbo.put("name", name); // in v1: Only used for creating/uploading new image. Otherwise it's always null.
			dbo.put("uri", originalUri);
			dbo.put("fileName", originalName);
			dbo.put("contentType", contentType);
			dbo.put("size", (int)length);
			final Date creationTime = new Date();
			dbo.put("created", creationTime);
			dbo.put("styles", stylesObj);
- originalFile : transient

v2 adds:

			dbo.put("name", name); // in v2: serialized
			dbo.put("originUri", originalOriginUri);
			dbo.put("extension", extension);
			dbo.put("creationTime", creationTime);
- modificationTime
- width
- height
- linkedFile</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="StyledImage">
    <xsd:annotation>
      <xsd:documentation>StyledImage v1 is as follows:

				bson.put("code", transformed.getStyleCode());
				bson.put("uri", transformed.getUri());
				bson.put("size", transformed.getSize());
				bson.put("width", transformed.getWidth());
				bson.put("height", transformed.getHeight());

v2 adds:

				bson.put("className", StyledImage.class.getName()); // META
				bson.put("name", style.getName());
				bson.put("variant", transformed.getStyleVariant());
				bson.put("extension", transformed.getExtension());
				bson.put("originUri", transformed.getOriginUri());
				bson.put("contentType", "image/jpeg"); // TODO: don't hardcode content type
- creationTime
- modificationTime
</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="commons:SchemaVersionable">
        <xsd:attribute name="width" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Width of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="height" type="xsd:int">
          <xsd:annotation>
            <xsd:documentation>Height of desired image</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="name" type="xsd:string" use="required"/>
        <xsd:attribute name="creationTime" type="xsd:string"/>
        <xsd:attribute name="modificationTime" type="xsd:string"/>
        <xsd:attribute name="schemaVersion" type="xsd:long"/>
        <xsd:attribute name="code" type="xsd:string"/>
        <xsd:attribute name="uri" type="xsd:string"/>
        <xsd:attribute name="size" type="xsd:long"/>
        <xsd:attribute name="variant" type="xsd:string"/>
        <xsd:attribute name="extension" type="xsd:string"/>
        <xsd:attribute name="originUri" type="xsd:string"/>
        <xsd:attribute name="contentType" type="xsd:string"/>
        <xsd:attribute name="linkedFile" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>Image file name, relative to XMI file path inside the export folder or archive file. Only used for XMI data.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="StyledImage" type="image:StyledImage">
    <xsd:annotation>
      <xsd:documentation>StyledImage v1 is as follows:

				bson.put("code", transformed.getStyleCode());
				bson.put("uri", transformed.getUri());
				bson.put("size", transformed.getSize());
				bson.put("width", transformed.getWidth());
				bson.put("height", transformed.getHeight());

v2 adds:

				bson.put("className", StyledImage.class.getName()); // META
				bson.put("name", style.getName());
				bson.put("variant", transformed.getStyleVariant());
				bson.put("extension", transformed.getExtension());
				bson.put("originUri", transformed.getOriginUri());
				bson.put("contentType", "image/jpeg"); // TODO: don't hardcode content type
- creationTime
- modificationTime
</xsd:documentation>
    </xsd:annotation>
  </xsd:element>
  <xsd:complexType name="ImageCatalog">
    <xsd:choice maxOccurs="unbounded" minOccurs="0">
      <xsd:element name="images" type="image:Image"/>
      <xsd:element ref="xmi:Extension"/>
    </xsd:choice>
    <xsd:attribute ref="xmi:id"/>
    <xsd:attributeGroup ref="xmi:ObjectAttribs"/>
  </xsd:complexType>
  <xsd:element name="ImageCatalog" type="image:ImageCatalog"/>
</xsd:schema>
